// Package effect demonstrates dependency injection using the Effect pattern.
//
// This test file shows how to build a type-safe dependency injection system where:
// - An InjectionContainer can resolve services by ID (InjectionToken)
// - Services are generic effects that depend on the container
// - Lookup methods convert from untyped container to typed dependencies
// - Handler functions depend type-safely on specific service interfaces
package effect

import (
	"errors"
	"fmt"
	"testing"

	thunk "github.com/IBM/fp-go/v2/context/readerioresult"
	F "github.com/IBM/fp-go/v2/function"
	"github.com/IBM/fp-go/v2/result"
)

type (
	// InjectionToken is a unique identifier for services in the container
	InjectionToken string

	// InjectionContainer is an Effect that resolves services by their token.
	// It takes an InjectionToken and returns a Thunk that produces any type.
	// This allows the container to store and retrieve services of different types.
	InjectionContainer = Effect[InjectionToken, any]

	// Service is a generic Effect that depends on the InjectionContainer.
	// It represents a computation that needs access to the dependency injection
	// container to resolve its dependencies before producing a string result.
	Service[T any] = Effect[InjectionContainer, T]

	// Service1 is an example service interface that can be resolved from the container
	Service1 interface {
		GetService1() string
	}

	// Service2 is another example service interface
	Service2 interface {
		GetService2() string
	}

	// impl1 is a concrete implementation of Service1
	impl1 struct{}
	// impl2 is a concrete implementation of Service2
	impl2 struct{}
)

// ComplexService demonstrates a more complex dependency injection scenario
// where a service depends on multiple other services. This struct aggregates
// Service1 and Service2, showing how to compose dependencies.
// The fp-go:Lens directive generates lens functions for type-safe field access.
//
// fp-go:Lens
type ComplexService struct {
	service1 Service1
	service2 Service2
}

func (_ *impl1) GetService1() string {
	return "service1"
}

func (_ *impl2) GetService2() string {
	return "service2"
}

const (
	// service1 is the injection token for Service1
	service1 = InjectionToken("service1")
	// service2 is the injection token for Service2
	service2 = InjectionToken("service2")
)

var (
	// complexServiceLenses provides type-safe accessors for ComplexService fields,
	// generated by the fp-go:Lens directive. These lenses are used in applicative
	// composition to build the ComplexService from individual dependencies.
	complexServiceLenses = MakeComplexServiceLenses()
)

// makeSampleInjectionContainer creates an InjectionContainer that can resolve services by ID.
// The container maps InjectionTokens to their corresponding service implementations.
// It returns an error if a requested service is not available.
func makeSampleInjectionContainer() InjectionContainer {

	return func(token InjectionToken) Thunk[any] {
		switch token {
		case service1:
			return thunk.Of(any(&impl1{}))
		case service2:
			return thunk.Of(any(&impl2{}))
		default:
			return thunk.Left[any](errors.New("dependency not available"))
		}
	}
}

// handleService1 is an Effect that depends type-safely on Service1.
// It demonstrates how to write handlers that work with specific service interfaces
// rather than the untyped container, providing compile-time type safety.
func handleService1() Effect[Service1, string] {
	return func(ctx Service1) ReaderIOResult[string] {
		return thunk.Of(fmt.Sprintf("Service1: %s", ctx.GetService1()))
	}
}

// handleComplexService is an Effect that depends on ComplexService, which itself
// aggregates multiple service dependencies (Service1 and Service2).
// This demonstrates how to work with composite dependencies in a type-safe manner.
func handleComplexService() Effect[ComplexService, string] {
	return func(ctx ComplexService) ReaderIOResult[string] {
		return thunk.Of(fmt.Sprintf("ComplexService: %s x %s", ctx.service1.GetService1(), ctx.service2.GetService2()))
	}
}

// lookupService1 is a lookup method that converts from an untyped InjectionContainer
// to a typed Service1 dependency. It performs two steps:
// 1. Read[any](service1) - retrieves the service from the container by token
// 2. ChainResultK(result.InstanceOf[Service1]) - safely casts from any to Service1
// This conversion provides type safety when moving from the untyped container to typed handlers.
var lookupService1 = F.Flow2(
	Read[any](service1),
	thunk.ChainResultK(result.InstanceOf[Service1]),
)

// lookupService2 is a lookup method for Service2, following the same pattern as lookupService1.
// It retrieves Service2 from the container and safely casts it to the correct type.
var lookupService2 = F.Flow2(
	Read[any](service2),
	thunk.ChainResultK(result.InstanceOf[Service2]),
)

// lookupComplexService demonstrates applicative composition for complex dependency injection.
// It builds a ComplexService by composing multiple service lookups:
// 1. Do[InjectionContainer](ComplexService{}) - starts with an empty ComplexService in the Effect context
// 2. ApSL(complexServiceLenses.service1, lookupService1) - looks up Service1 and sets it using the lens
// 3. ApSL(complexServiceLenses.service2, lookupService2) - looks up Service2 and sets it using the lens
//
// This applicative style allows parallel composition of independent dependencies,
// building the complete ComplexService from its constituent parts in a type-safe way.
var lookupComplexService = F.Pipe2(
	Do[InjectionContainer](ComplexService{}),
	ApSL(complexServiceLenses.service1, lookupService1),
	ApSL(complexServiceLenses.service2, lookupService2),
)

// handleResult is a curried function that combines results from two services.
// It demonstrates how to compose the outputs of multiple effects into a final result.
// The curried form allows it to be used with applicative composition (ApS).
func handleResult(s1 string) func(string) string {
	return func(s2 string) string {
		return fmt.Sprintf("Final Result: %s : %s", s1, s2)
	}
}

// TestDependencyLookup demonstrates both simple and complex dependency injection patterns:
//
// Simple Pattern (handle1):
// 1. Create an InjectionContainer with registered services
// 2. Define a handler (handleService1) that depends on a single typed service interface
// 3. Use a lookup method (lookupService1) to resolve the dependency from the container
// 4. Compose the handler with the lookup using LocalThunkK to inject the dependency
//
// Complex Pattern (handleComplex):
// 1. Define a handler (handleComplexService) that depends on a composite service (ComplexService)
// 2. Use applicative composition (lookupComplexService) to build the composite from multiple lookups
// 3. Each sub-dependency is resolved independently and combined using lenses
// 4. LocalThunkK injects the complete composite dependency into the handler
//
// Service Composition:
// - ApS combines the results of handle1 and handleComplex using handleResult
// - This demonstrates how to compose multiple independent effects that share the same container
// - The final result aggregates outputs from both simple and complex dependency patterns
func TestDependencyLookup(t *testing.T) {

	// Create the dependency injection container
	container := makeSampleInjectionContainer()

	// Simple dependency injection: single service lookup
	// LocalThunkK transforms the handler to work with the container
	handle1 := F.Pipe1(
		handleService1(),
		LocalThunkK[string](lookupService1),
	)

	// Complex dependency injection: composite service with multiple dependencies
	// lookupComplexService uses applicative composition to build ComplexService
	handleComplex := F.Pipe1(
		handleComplexService(),
		LocalThunkK[string](lookupComplexService),
	)

	// Compose both services using applicative style
	// ApS applies handleResult to combine outputs from handle1 and handleComplex
	result := F.Pipe1(
		handle1,
		ApS(handleResult, handleComplex),
	)

	// Execute: provide container, then context, then run the IO operation
	res := result(container)(t.Context())()

	fmt.Println(res)

}
